-- do not pollute the global environment
local t = {}
package.seeall(t)
setfenv(0, t)

-- short-cuts
local C = context
local format = string.format
local debug = tex.modes.debug

-- main table
local cats = dofile"categories.lua"

-- Call back for cid-files.
-- todo
function general_settings(...)
end

-- Call back for cid-files.
-- todo
function general_keywords(...)
end

-- Format the command name.
-- Add backslach, add start-stop and so on
-- c: command table
-- o: options string
-- return: tex-string for nice looking command name
local function format_cmd_name(c, o)
    local s = "\\textbackslash " .. c.name
    if o then
        s = s .. o
    end
    if c.environment then
        s = s .. " ... \\textbackslash "
        local stop = "ERROR"
        if c.name:find("^b") then
            stop = c.name:gsub("^(b)", "e")
        elseif c.name:find("^start") then
            stop = c.name:gsub("^(start)", "stop")
        end
        s = s .. stop
    end
    return format("\\mono{%s}", s)
end

-- Build a nice string for presentation of an argument.
-- t: type of argument
-- n: name of argument
-- return: nice TeX-string
-- todo: metatable for square_brackets and so on
-- todo: put n somewhere
local function build_arg_string(t, n)
    local s = {
        keywords = "[...]",
        settings = "[..,..=..,..]",
        text = "\\{...\\}",
    }
    return s[t] or format("[%s]", n)
end

-- Print one variants of the command.
-- c: command table
-- v: variant table
local function print_variant(c, v)
    local s = ""
    for i, a in ipairs(v) do
        s = s .. build_arg_string(c.arguments[a].type, a)
    end
    C(format_cmd_name(c, s))
    C.par()
    C(v.comment)
    C.par()
    C(v.description)
end

-- Print the syntax description of the command.
-- c: command table
local function print_syntax(c)
    C.startsubsection{title = "Invocation"}
    if #c.variants > 1 then
        for i, v in ipairs(c.variants) do
            C.startsubsubsection{title = "Variant " .. i}
            print_variant(c, v)
            C.stopsubsubsection()
        end
    else
        print_variant(c, c.variants[1])
    end
    C.stopsubsection()
    C.startsubsection{title = "Arguments"}
    for a, t in pairs(c.arguments) do
        C.relax()
        C.mono(build_arg_string(t.type, a) .. ": ")
        C(t.comment)
        C.par()
        C(t.description)
        C.blank()
    end
    C.stopsubsection()
end

-- Print a section with a command description.
-- c: the command table
local function print_command(c)
    if c.status == "initial" and not debug then
        return
    end
    local date, author =
        c.vc_id:match("^%$Id: .- (%d%d%d%d%-%d%d%-%d%d) .- (%w+) %$$")
    if not date then
        date, author = "???", "???"
    end
    C.startsection{title = format_cmd_name(c), reference = c.name}
    if debug then
        C.inmargin(format("%s: %s,\\crlf %s: %s,\\crlf %s: %s",
                          "Last update", date, "Status", c.status,
                          "Last author", author))
    end
    C(c.comment)
    C.par()
    C(c.description)
    print_syntax(c)
    C.stopsection()
end

-- Print related commands.
-- r: table with related commands
local function print_related_commands(r)
    if #r > 0 then
        C.startsection{title = "Related commands"}
        C.startRelatedCommands()
        for _, c in ipairs(r) do
            C.RelatedCommand{name = format_cmd_name(c),
                             comment = c.comment, reference = c.name}
        end
        C.stopRelatedCommands()
        C.stopsection()
    end
end

-- Print a category with it's commands.
-- cat: category table
local function print_category(cat)
    C.startchapter{title = cat.title}
    for _, c in ipairs(cat.commands) do
        print_command(c)
    end
    print_related_commands(cat.related)
    C.stopchapter()
end

-- Extend the category table with references by labels.
-- And add commands and related tables to each entry.
local function prepare_cats_table()
    for i, c in ipairs(cats) do
        c.commands, c.related = {}, {}
        cats[c.label] = c
    end
end

-- Read the cid files and put the content into the category table.
local function read_cid_files()
    local d = "commands"
	for f in lfs.dir(d) do
        local b = f:match("^(.*)%.cid$")
        if b then
            local cid = dofile(d .. "/" .. f)
            for i, c in ipairs(cid.categories) do
                table.insert(cats[c][i == 1 and "commands" or "related"], cid)
            end
        end
    end
    for _, c in ipairs(cats) do
        local function sort_by_name(a, b) return a.name < b.name end
        table.sort(c.commands, sort_by_name)
        table.sort(c.related, sort_by_name)
    end
end

-- do the real job
prepare_cats_table()
read_cid_files()
C("\\environment e-ctx-ref ")
C.starttext()
-- C.titlepage()
for _, c in ipairs(cats) do
    print_category(c)
end
-- print_index()
C.stoptext()
